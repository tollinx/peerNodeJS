(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var n=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var L=Object.prototype.hasOwnProperty;var g=(e,t)=>{for(var o in t)n(e,o,{get:t[o],enumerable:!0})},I=(e,t,o,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of _(t))!L.call(e,r)&&r!==o&&n(e,r,{get:()=>t[r],enumerable:!(s=y(t,r))||s.enumerable});return e};var N=e=>I(n({},"__esModule",{value:!0}),e);var q={};g(q,{AbortError:()=>i,AggregateCodeError:()=>l,CodeError:()=>a,CustomEvent:()=>b,ERR_INVALID_MESSAGE:()=>X,ERR_INVALID_PARAMETERS:()=>G,ERR_NOT_FOUND:()=>j,ERR_TIMEOUT:()=>F,Ed25519:()=>w,FaultTolerance:()=>p,InvalidCryptoExchangeError:()=>x,InvalidCryptoTransmissionError:()=>u,KEEP_ALIVE:()=>C,RSA:()=>P,StrictNoSign:()=>k,StrictSign:()=>U,TopicValidatorResult:()=>c,TypedEventEmitter:()=>m,UnexpectedPeerError:()=>f,connectionSymbol:()=>S,contentRoutingSymbol:()=>v,isConnection:()=>T,isPeerId:()=>M,isStartable:()=>E,isTransport:()=>B,peerDiscoverySymbol:()=>D,peerIdSymbol:()=>R,peerRoutingSymbol:()=>V,secp256k1:()=>O,setMaxListeners:()=>Y,start:()=>H,stop:()=>K,transportSymbol:()=>A});var S=Symbol.for("@libp2p/connection");function T(e){return e!=null&&!!e[S]}var v=Symbol.for("@libp2p/content-routing");var w="Ed25519",P="RSA",O="secp256k1";var D=Symbol.for("@libp2p/peer-discovery");var R=Symbol.for("@libp2p/peer-id");function M(e){return e!=null&&!!e[R]}var V=Symbol.for("@libp2p/peer-routing");var C="keep-alive";var U="StrictSign",k="StrictNoSign",c;(function(e){e.Accept="accept",e.Ignore="ignore",e.Reject="reject"})(c||(c={}));var A=Symbol.for("@libp2p/transport");function B(e){return e!=null&&!!e[A]}var p;(function(e){e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(p||(p={}));var i=class e extends Error{code;type;constructor(t="The operation was aborted"){super(t),this.code=e.code,this.type=e.type}static code="ABORT_ERR";static type="aborted"},a=class extends Error{code;props;constructor(t,o,s){super(t),this.code=o,this.name=s?.name??"CodeError",this.props=s??{}}},l=class extends AggregateError{code;props;constructor(t,o,s,r){super(t,o),this.code=s,this.name=r?.name??"AggregateCodeError",this.props=r??{}}},f=class e extends Error{code;constructor(t="Unexpected Peer"){super(t),this.code=e.code}static code="ERR_UNEXPECTED_PEER"},x=class e extends Error{code;constructor(t="Invalid crypto exchange"){super(t),this.code=e.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"},u=class e extends Error{code;constructor(t="Invalid crypto transmission"){super(t),this.code=e.code}static code="ERR_INVALID_CRYPTO_TRANSMISSION"},F="ERR_TIMEOUT",G="ERR_INVALID_PARAMETERS",j="ERR_NOT_FOUND",X="ERR_INVALID_MESSAGE";var m=class extends EventTarget{#t=new Map;listenerCount(t){let o=this.#t.get(t);return o==null?0:o.length}addEventListener(t,o,s){super.addEventListener(t,o,s);let r=this.#t.get(t);r==null&&(r=[],this.#t.set(t,r)),r.push({callback:o,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(t,o,s){super.removeEventListener(t.toString(),o??null,s);let r=this.#t.get(t);r!=null&&(r=r.filter(({callback:h})=>h!==o),this.#t.set(t,r))}dispatchEvent(t){let o=super.dispatchEvent(t),s=this.#t.get(t.type);return s==null||(s=s.filter(({once:r})=>!r),this.#t.set(t.type,s)),o}safeDispatchEvent(t,o={}){return this.dispatchEvent(new b(t,o))}},d=class extends Event{detail;constructor(t,o){super(t,o),this.detail=o?.detail}},b=globalThis.CustomEvent??d;var Y=(e,...t)=>{try{[...t]}catch{}};function E(e){return e!=null&&typeof e.start=="function"&&typeof e.stop=="function"}async function H(...e){let t=[];for(let o of e)E(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStart!=null&&await o.beforeStart()})),await Promise.all(t.map(async o=>{await o.start()})),await Promise.all(t.map(async o=>{o.afterStart!=null&&await o.afterStart()}))}async function K(...e){let t=[];for(let o of e)E(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStop!=null&&await o.beforeStop()})),await Promise.all(t.map(async o=>{await o.stop()})),await Promise.all(t.map(async o=>{o.afterStop!=null&&await o.afterStop()}))}return N(q);})();
return Libp2PInterface}));

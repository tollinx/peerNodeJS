import http from 'http';
import { logger } from '@libp2p/logger';
import { base58btc } from 'multiformats/bases/base58';
import { toString } from 'uint8arrays/to-string';
import { fromString } from 'uint8arrays/from-string';
import { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';
import { ipPortToMultiaddr } from '@libp2p/utils/ip-port-to-multiaddr';
import { toMultiaddrConnection } from './socket-to-conn.js';
import { WebRTCReceiver } from '@libp2p/webrtc-peer';
import errCode from 'err-code';
import { pEvent } from 'p-event';
const log = logger('libp2p:webrtc-direct:listener');
class WebRTCDirectServer extends EventEmitter {
    constructor(multiaddr, wrtc, receiverOptions) {
        super();
        this.connections = [];
        this.channels = [];
        this.wrtc = wrtc;
        this.receiverOptions = receiverOptions;
        this.server = http.createServer();
        this.server.on('request', (req, res) => {
            void this.processRequest(req, res).catch(err => {
                log.error(err);
            });
        });
        this.server.on('error', (err) => this.dispatchEvent(new CustomEvent('error', { detail: err })));
        const lOpts = multiaddr.toOptions();
        this.server.on('listening', (err) => {
            if (err != null) {
                this.dispatchEvent(new CustomEvent('error', { detail: err }));
                return;
            }
            this.dispatchEvent(new CustomEvent('listening'));
            log('Listening on %s %s', lOpts.port, lOpts.host);
        });
        this.server.listen(lOpts);
    }
    async processRequest(req, res) {
        const remoteAddress = req?.socket?.remoteAddress;
        const remotePort = req?.socket.remotePort;
        const remoteHost = req.headers.host;
        const requestUrl = req.url;
        if (remoteAddress == null || remotePort == null || requestUrl == null || remoteHost == null) {
            const err = new Error('Invalid listener request. Specify request\'s url, remoteAddress, remotePort.');
            log.error(err);
            res.writeHead(500);
            res.end(err);
            return;
        }
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Access-Control-Allow-Origin', '*');
        const url = new URL(requestUrl, `http://${remoteHost}`);
        const incSignalStr = url.searchParams.get('signal');
        if (incSignalStr == null) {
            const err = new Error('Invalid listener request. Signal not found.');
            log.error(err);
            res.writeHead(500);
            res.end(err);
            return;
        }
        const incSignalBuf = base58btc.decode(incSignalStr);
        const incSignal = JSON.parse(toString(incSignalBuf));
        if (incSignal.type !== 'offer') {
            // offers contain candidates so only respond to the offer
            res.end();
            return;
        }
        const channel = new WebRTCReceiver({
            wrtc: this.wrtc,
            ...this.receiverOptions
        });
        this.channels.push(channel);
        channel.addEventListener('signal', (evt) => {
            const signal = evt.detail;
            const signalStr = JSON.stringify(signal);
            const signalEncoded = base58btc.encode(fromString(signalStr));
            res.end(signalEncoded);
        });
        channel.addEventListener('error', (evt) => {
            const err = evt.detail;
            log.error('incoming connection errored with', err);
            res.end();
            void channel.close().catch(err => {
                log.error(err);
            });
        });
        channel.addEventListener('ready', () => {
            const maConn = toMultiaddrConnection(channel, {
                remoteAddr: ipPortToMultiaddr(remoteAddress, remotePort)
            });
            log('new inbound connection %s', maConn.remoteAddr);
            this.connections.push(maConn);
            const untrackConn = () => {
                this.connections = this.connections.filter(c => c !== maConn);
                this.channels = this.channels.filter(c => c !== channel);
            };
            channel.addEventListener('close', untrackConn, {
                once: true
            });
            this.dispatchEvent(new CustomEvent('connection', { detail: maConn }));
        });
        channel.handleSignal(incSignal);
    }
    async close() {
        await Promise.all(this.channels.map(async (channel) => { await channel.close(); }));
        await new Promise((resolve, reject) => {
            this.server.close((err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    }
}
class WebRTCDirectListener extends EventEmitter {
    constructor(upgrader, wrtc, receiverOptions, handler) {
        super();
        this.upgrader = upgrader;
        this.wrtc = wrtc;
        this.receiverOptions = receiverOptions;
        this.handler = handler;
    }
    async listen(multiaddr) {
        // Should only be used if not already listening
        if (this.multiaddr != null) {
            throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');
        }
        this.multiaddr = multiaddr;
        const server = new WebRTCDirectServer(multiaddr, this.wrtc, this.receiverOptions);
        this.server = server;
        this.server.addEventListener('connection', (evt) => {
            void this.onConnection(evt.detail).catch(err => {
                log.error(err);
            });
        });
        await pEvent(server, 'listening');
        this.dispatchEvent(new CustomEvent('listening'));
    }
    async onConnection(maConn) {
        let connection;
        try {
            connection = await this.upgrader.upgradeInbound(maConn);
        }
        catch (err) {
            log.error('inbound connection failed to upgrade', err);
            await maConn.close();
            return;
        }
        log('inbound connection %s upgraded', maConn.remoteAddr);
        if (this.handler != null) {
            this.handler(connection);
        }
        this.dispatchEvent(new CustomEvent('connection', { detail: connection }));
    }
    async close() {
        if (this.server != null) {
            await this.server.close();
        }
        this.dispatchEvent(new CustomEvent('close'));
    }
    getAddrs() {
        if (this.multiaddr != null) {
            return [this.multiaddr];
        }
        return [];
    }
}
export function createListener(options) {
    return new WebRTCDirectListener(options.upgrader, options.wrtc, options.receiverOptions, options.handler);
}
//# sourceMappingURL=listener.js.map